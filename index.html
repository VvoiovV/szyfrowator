<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Szyfrowanie i Deszyfrowanie</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Szyfrowanie i Deszyfrowanie</h1>

    <canvas id="matrixCanvas"></canvas>

    <section>
        <h2>Szyfr Cezara</h2>
        <p><strong>Opis:</strong> 
            Szyfr Cezara to jeden z najstarszych i najprostszych szyfrów podstawieniowych. Jego historia sięga czasów starożytnego Rzymu,
             gdzie według legendy był używany przez Juliusza Cezara do tajnej korespondencji. Algorytm ten opiera się na przesunięciu liter alfabetu o stałą liczbę pozycji.
        </p>
                
        <div class="flex-container">
            <div class="left">
                <textarea id="caesarInput" placeholder="Wpisz tekst..."></textarea><br>
                <input type="number" id="caesarShift" placeholder="Podaj przesunięcie (np. 3)" />
                <div>
                    <button onclick="encryptCaesar()">Zaszyfruj</button>
                    <button onclick="decryptCaesar()">Odszyfruj</button>
                </div>
                <textarea id="caesarOutput" placeholder="Wynik..." readonly></textarea>
            </div>
            <div class="right">
                <p><strong>Opis:</strong> 
                    Każda litera w wiadomości jest przesuwana o stałą liczbę pozycji w alfabecie. Jeśli przesunięcie (klucz) wynosi (k), wtedy
                     Dla szyfrowania: C = (P + k) mod N
                     Dla deszyfrowania: P = (C - k) mod N
                    
                    Gdzie
                     P to litera w tekście jawnym.
                     C to litera w szyfrogramie.
                     N to liczba liter w alfabecie.
                </p>
                <p><strong>Przykład:</strong> 
                     Tekst jawny `HELLO`
                     Przesunięcie klucz k = 3
                     Szyfrowanie `KHOOR`
                      H → K E → H L → O L → O O → R
                </p>
            </div>
        </div>
    </section>

    <section>
        <h2>Szyfr Polibiusza</h2>
        <p><strong>Opis:</strong> RSA (Rivest–Shamir–Adleman) to jeden z najważniejszych i najpowszechniej stosowanych algorytmów szyfrowania asymetrycznego. Został opracowany w 1977 roku przez trzech naukowców z MIT: Rona Rivesta, Adi'ego Shamira i Leonarda Adlemana. Algorytm ten bazuje na trudności faktoryzacji (rozkładu) dużych liczb na czynniki pierwsze, co czyni go bezpiecznym przy odpowiednio dużych kluczach. Podaj klucz publiczny i prywatny w odpowiednim formacie (np. „17,3233”).</p>
                
        <div class="flex-container">
            <div class="left">
                <textarea id="polibiusInput" placeholder="Wpisz tekst..."></textarea><br>
                <div>
                    <button onclick="encryptPolibius()">Zaszyfruj</button>
                    <button onclick="decryptPolibius()">Odszyfruj</button>
                </div>
                <textarea id="polibiusOutput" placeholder="Wynik..." readonly></textarea>
            </div>
            <div class="right">
                <p><strong>Opis:</strong> Szyfr Polibiusza wykorzystuje tabelę 5x5, w której każda litera jest identyfikowana przez współrzędne wiersza i kolumny. Litera „I” i „J” są traktowane jako jeden znak. Tabela obsługuje polskie litery.</p>
            </div>
        </div>
    </section>

    <section>
        <h2>Szyfr Vigenère'a</h2>
        <p><strong>Opis:</strong> RSA (Rivest–Shamir–Adleman) to jeden z najważniejszych i najpowszechniej stosowanych algorytmów szyfrowania asymetrycznego. Został opracowany w 1977 roku przez trzech naukowców z MIT: Rona Rivesta, Adi'ego Shamira i Leonarda Adlemana. Algorytm ten bazuje na trudności faktoryzacji (rozkładu) dużych liczb na czynniki pierwsze, co czyni go bezpiecznym przy odpowiednio dużych kluczach. Podaj klucz publiczny i prywatny w odpowiednim formacie (np. „17,3233”).</p>
                
        <div class="flex-container">
            <div class="left">
                <textarea id="vigenereInput" placeholder="Wpisz tekst..."></textarea><br>
                <input type="text" id="vigenereKey" placeholder="Podaj klucz (np. KLUCZ)" />
                <div>
                    <button onclick="encryptVigenere()">Zaszyfruj</button>
                    <button onclick="decryptVigenere()">Odszyfruj</button>
                </div>
                <textarea id="vigenereOutput" placeholder="Wynik..." readonly></textarea>
            </div>
            <div class="right">
                <p><strong>Opis:</strong> Szyfr Vigenère'a używa klucza do określenia przesunięcia każdej litery w tekście. Obsługiwane są polskie litery.</p>
            </div>
        </div>
    </section>

    <section>
        <h2>Szyfr RSA</h2>
        <p><strong>Opis:</strong> RSA (Rivest–Shamir–Adleman) to jeden z najważniejszych i najpowszechniej stosowanych algorytmów szyfrowania asymetrycznego. Został opracowany w 1977 roku przez trzech naukowców z MIT: Rona Rivesta, Adi'ego Shamira i Leonarda Adlemana. Algorytm ten bazuje na trudności faktoryzacji (rozkładu) dużych liczb na czynniki pierwsze, co czyni go bezpiecznym przy odpowiednio dużych kluczach. Podaj klucz publiczny i prywatny w odpowiednim formacie (np. „17,3233”).</p>
                
        <div class="flex-container">
            <div class="left">
                <textarea id="rsaInput" placeholder="Wpisz tekst..."></textarea><br>
                <input type="text" id="rsaPublicKey" placeholder="Klucz publiczny (np. e,n)" />
                <input type="text" id="rsaPrivateKey" placeholder="Klucz prywatny (np. d,n)" />
                <div>
                    <button onclick="encryptRSA()">Zaszyfruj</button>
                    <button onclick="decryptRSA()">Odszyfruj</button>
                </div>
                <textarea id="rsaOutput" placeholder="Wynik..." readonly></textarea>
                <h2>Generator Kluczy</h2>
                <button onclick="generateAndDisplayKeys()">Generuj Klucze</button>
                <div>
                    <p><strong>Klucz Publiczny:</strong> <span id="publicKey"></span></p>
                    <p><strong>Klucz Prywatny:</strong> <span id="privateKey"></span></p>
                </div>
                <p><strong>Różnice:</strong>
                    kod implementuje uproszczoną wersję RSA, która działa zgodnie z powyższymi zasadami, ale z pewnymi uproszczeniami
                    Liczby pierwsze p i q są losowane w zakresie od 50 do 100 (bardzo małe liczby w porównaniu do praktycznych zastosowań, gdzie p i q mają tysiące bitów).
                    Wiadomości są przekształcane na kody ASCII, a każda litera jest szyfrowana indywidualnie. W praktyce szyfrowane są całe bloki danych, a nie pojedyncze litery.
                    Do obliczeń używam prostego algorytmu potęgowania modularnego. W praktyce Wykorzystuje się bardziej zaawansowane metody, takie jak szybkie potęgowanie modularne i systemy rozproszone.
                </p>
            </div>
            <div class="right">
                <p><strong>Opis:</strong>Wcześniejsze metody szyfrowania, takie jak szyfry symetryczne (np. AES), wymagały wspólnego klucza dla nadawcy i odbiorcy.
                    Problemem było bezpieczne przesyłanie klucza - jeśli ktoś przechwycił klucz, mógł złamać całą komunikację.
                    W szyfrowaniu asymetrycznym każdy użytkownik ma dwa klucze
                    Klucz publiczny (do szyfrowania) - może być znany każdemu.
                    Klucz prywatny (do deszyfrowania) - trzymany w tajemnicy przez właściciela.
                    Umożliwia to bezpieczną wymianę informacji bez konieczności przesyłania tajnych kluczy.
                    RSA opiera się na trudności rozwiązania problemu faktoryzacji, czyli rozkładu liczby na czynniki pierwsze. Dla dużych liczb (np. 2048-bitowych) jest to praktycznie niemożliwe w rozsądnym czasie.
                </p>
                <p><strong>Działanie:</strong> 
                    Kroki generowania kluczy RSA:
                    1. Wybór dwóch dużych liczb pierwszych p i q Są one podstawą algorytmu. W praktyce liczby te muszą być ogromne (np. 1024 bity).
                    2. Obliczenie n=p⋅q n jest podstawą dla klucza publicznego i prywatnego.
                    3. Obliczenie funkcji Eulera ϕ(n)=(p-1)(q-1).
                    4. Wybór liczby e musi być względnie pierwsze z ϕ(n) (tzn. GCD(e,ϕ(n)) = 1). W praktyce często używa się małych wartości e, np. 65537.
                    5. Obliczenie klucza prywatnego d to odwrotność modularna e względem ϕ(n), co oznacza, że e⋅d mod ϕ(n)=1
                </p>
                <p><strong>Szyfrowanie i deszyfrowanie</strong>
                    Szyfrowanie za pomocą klucza publicznego (e,n)
                    Jeśli m to wiadomość (przekształcona na liczbę), to szyfrogram c oblicza się jako: c=me mod n
                    Deszyfrowanie za pomocą klucza prywatnego (d,n)Wiadomość m odzyskuje się jako 𝑚 =cd mod n
                </p>
            </div>
        </div>
    </section>

    <script src="script.js"></script>
</body>

    
    
</html>
